<a name="General_guidance_and_good_practice_for_testing"></a>

# General guidance and good practice for testing

هناك عدة {ref}`أنواع مختلفة`<rr-testing-types-of-testing> • الاختبار الذي يكون لكل واحد منه أفضل الممارسات الخاصة به. ومع ذلك، هناك بعض الإرشادات العامة التي تنطبق على جميع هذه البلدان، والتي سيتم إيجازها هنا.

(ص - اختبار - كتابة)=
## Write Tests - Any Tests!

بدء عملية اختبارات الكتابة يمكن أن يكون مغلقا، خاصة إذا كان لديك قاعدة رموز كبيرة. وعلاوة على ذلك، وكما ذكرنا فإن هناك أنواعا عديدة من الاختبارات، ويمكن أن يبدو تنفيذها جميعا كجبل مستحيل الصعود. ولهذا السبب فإن أهم توجيه في هذا الفصل هو كما يلي: **كتابة بعض الاختبارات**. اختبار شيء صغير في التعليمات البرمجية بطول آلاف الأسطر هو أفضل بلا حدود من اختبار لا شيء في التعليمات البرمجية التي تطول آلاف الأسطر. قد لا تكون قادراً على فعل كل شيء، ولكن القيام *بشيء* قيم.

إجراء تحسينات حيث يمكنك ذلك، وبذل قصارى جهدك لتضمين الاختبارات مع التعليمات البرمجية الجديدة التي تكتبها حتى لو لم يكن من الممكن كتابة الاختبارات لجميع التعليمات البرمجية المكتوبة بالفعل.

## Run the tests

ثاني أهم نصيحة في هذا الفصل: قم بتشغيل الاختبارات. إن وجود مجموعة اختبار جميلة مثالية لا يستخدم إذا كنت نادراً ما تشغلها. إن ترك فجوات طويلة بين عمليات الاختبار يزيد من صعوبة تتبع الخطأ الذي وقع عندما يفشل الاختبار، لأنه الكثير من التعليمات البرمجية ستكون قد تغيرت. وأيضا، إذا كان قد مضى أسابيع أو أشهر منذ إجراء الاختبارات وفشلت، ومن الصعب أو المستحيل معرفة ما هي النتائج التي تحققت في الوقت المتوسط التي لا تزال صالحة. والتي يجب أن تُلقى بعيداً لأنه كان يمكن أن تكون قد تأثرت بالخطأ.

من الأفضل أتمتة اختبارك قدر الإمكان. وإذا كان كل اختبار يحتاج إلى إجراء فردي، فمن المرجح أن تُهمل العملية المضنية المملة. يمكن القيام بذلك باستخدام إطار اختبار ([نوقش لاحقاً](#use-a-testing-framework)). [Jenkins](https://jenkins.io) أداة جيدة أخرى لهذا الغرض. قم بضبط اختباراتك بشكل مثالي لتعمل على فترات منتظمة، ربما كل ليلة.

النظر في إعداد التكامل المستمر (مناقشة في الفصل الخاص بالتكامل المستمر) في مشروعك. سيؤدي هذا تلقائياً إلى تشغيل الاختبارات الخاصة بك في كل مرة تقوم فيها بتغيير التعليمات البرمجية الخاصة بك، اعتمادًا على برنامج الدمج المستمر الذي تستخدمه، سيتم إعلامك إذا فشل أي من الاختبارات.

## Consider how long it takes your tests to run

بعض الاختبارات، مثل {ref}`محرر الاختبار` فقط اختبار قطعة صغيرة من التعليمات البرمجية وبالتالي عادة ما تكون سريعة جدا. غير أن أنواعاً أخرى من الاختبارات، مثل {ref}`نظام اختبار rr-test-system` التي تختبر الكود بأكمله من النهاية إلى النهاية، قد يستغرق تشغيله وقتاً طويلاً اعتماداً على التعليمات البرمجية. وعلى هذا النحو، قد يكون من المعوق إجراء مجموعة الاختبار بأكملها بعد كل جزء صغير من العمل. وفي هذه الحالة، من الأفضل إجراء اختبارات أقل وزنا مثل اختبارات الوحدة بشكل متكرر، واختبارات أطول أجلا مرة واحدة في اليوم بين عشية وضحاها. من الجيد أيضاً قياس عدد كل نوع من الاختبارات التي لديك فيما يتعلق بمدة تشغيلها. يجب أن يكون لديك الكثير من اختبارات الوحدة (أو أنواع أخرى من الاختبارات السريعة) ولكن أقل بكثير من الاختبارات التي تستغرق وقتا طويلا للتشغيل.

## Document the tests and how to run them

ومن المهم تقديم وثائق تصف كيفية إجراء الاختبارات، وكلاهما لنفسك في حالة عودتك إلى مشروع في المستقبل، ولأي شخص آخر يرغب في البناء على عملك أو استنساخه. وينبغي أن تشمل هذه الوثائق أيضاً مواضيع مثل

- Any resources, such as test dataset files that are required
- Any configuration/settings adjustments needed to run the tests
- ما هو البرنامج (مثل [أطر الاختبار](#use-a-testing-framework)) الذي يحتاج إلى تثبيته

من الناحية المثالية، يمكنك توفير البرامج النصية لإعداد وتكوين أي موارد مطلوبة.

## Test Realistic Cases

اجعل الحالات التي تختبرها واقعية قدر الإمكان. إذا على سبيل المثال، لديك بيانات غامضة لتشغيل الاختبارات عليك التأكد من أن البيانات مماثلة قدر الإمكان للبيانات الفعلية. إذا كانت بياناتك الفعلية فوضوية مع الكثير من القيم الفارغة، لذا يجب أن تكون مجموعة بيانات الاختبار الخاصة بك.

## Use a Testing Framework

وهناك أدوات متاحة لتيسير الكتابة وإجراء الاختبارات، وتعرف هذه الأدوات باسم أطر الاختبار. ابحث عن واحدة تحبها، اتعلم عن الميزات التي تعرضها، و استخدمها. وتشمل أطر الاختبار المشتركة (واللغات التي تنطبق عليها) ما يلي:

- Language agnostic
  - CTest, test runner for executables, bash scripts, and more. Great for legacy code hardening
- C++
  - Catch
  - CppTest
  - Boost::Test
  - google-test
- crwdns4427:0crwdne4427:0
  - all C++ frameworks
  - Check
  - CUnit
```{note}
While modern C++ and C are still mostly compatible, they're not completely and using test framework interchangeably may not always work.
```
- Python
  - pytest (recommended)
  - unittest comes with standard Python library
- R unit-tests
  - testthat
  - tinytest
  - svUnit (works with SciViews GUI)
- Fortran unit-tests:
  - funit
  - pfunit (works with MPI)
- جوليا
  - Test.jl (stdlib)
  - ReTest.jl

## Aim to have a good code coverage

تغطية الكود هي مقياس لمقدار الكود الخاص بك "المشمول" بالتجارب. بمزيد من الدقة فإنه مقياس لكمية التعليمات البرمجية الخاصة بك التي يتم تشغيلها عند إجراء الاختبارات. لذا على سبيل المثال، إذا كان لديك بيان `إذا` ولكن فقط اختبر الأشياء التي يقوم فيها هذا البيان بتقييم "False" فلن يتم تشغيل أي من التعليمات البرمجية في الكتلة إذا تم تشغيل الكتلة. ونتيجة لذلك، ستكون تغطية التعليمات البرمجية الخاصة بك < 100%. التغطية البرمجية لا تشمل الوثائق مثل التعليقات، لذا فإن إضافة المزيد من الوثائق لا تؤثر على النسب المئوية.

وكما نوقش فإن أي اختبارات تمثل تحسنا عن عدم وجود اختبارات. ومع ذلك، من الجيد أن تطمح على الأقل إلى أن تكون تغطية التعليمات البرمجية الخاصة بك عالية قدر الإمكان.

ومعظم لغات البرمجة لديها أدوات إما مدمجة فيها، أو يمكن استيرادها، أو كجزء من أطر الاختبار، التي تقيس تلقائياً تغطية الرموز. هناك [بوت صغير لطيف](https://codecov.io/) لقياس تغطية التعليمات البرمجية المتاحة أيضا.

**Pitfall: وهم التغطية الجيدة.** في بعض الحالات، يمكن بل ربما ينبغي اختبار نفس الكود بطرق متعددة. على سبيل المثال، يمكن للتغطية أن تزيد بسرعة على التعليمات البرمجية التي تطبق اختبارات "التحقق من الصحة العامة" على إخراجها (انظر أيضا {ref}<rr-testing-challenges-difficult-quatify>)، ولكن هذا لا يستبعد احتمال أن تنتج التعليمات البرمجية الإجابة الصحيحة بشكل عام لأسباب خاطئة. وبوجه عام، فإن أفضل الاختبارات هي تلك التي تعزل الأجزاء الأصغر حجما بدلا من الأجزاء الأكبر من الشفرة المتسقة، وهكذا اختر خطوات فردية من المنطق. حاول أن تسترشد بالتفكير في الأشياء المحتملة التي قد تحدث لجزء معين من التعليمات البرمجية في تنفيذ الكل، واختبر هذه الحالات الفردية. في كثير من الأحيان، سيؤدي هذا إلى اختبار نفس الكود عدة مرات - هذا شيء جيد!

## Use test doubles/stubs/mocking where appropriate

وفي حالة فشل الاختبار، ينبغي أن يوضع بحيث يكون من السهل تتبع مصدر الفشل قدر الإمكان. هذا يصبح مشكلة إذا كان جزء من التعليمات البرمجية تريد اختبارها يعتمد بشكل لا مفر منه على أشياء أخرى. على سبيل المثال إذا فشل اختبار لجزء من التعليمات البرمجية التي تتفاعل مع الويب، قد يكون ذلك لأن الكود يحتوي على خطأ *أو* بسبب وجود مشكلة في الاتصال بالإنترنت. وبالمثل، إذا فشل اختبار لجزء من التعليمات البرمجية التي تستخدم كائنا ما يمكن أن يكون بسبب وجود خلل في التعليمات البرمجية التي يجري اختبارها، أو مشكلة مع الجسم (الذي ينبغي اختباره بواسطة اختبارات منفصلة خاصة به). وينبغي إزالة هذه التبعيات من الاختبارات، إن أمكن. ويمكن القيام بذلك باستخدام بدائل الاختبار (مضاعفات الاختبار) بدلا من التبعيات الحقيقية. ويمكن تصنيف المزدوج الاختباري على النحو التالي:

- A dummy object is passed around but never used, meaning its methods are never called. Such an object can for example be used to fill the parameter list of a method.
- Fake objects have working implementations, but are usually simplified. For example, they use an in memory database and not a real database.
- A stub is a partial implementation for an interface or class with the purpose of using an instance of this stub during testing. Stubs usually don’t respond to anything outside what’s programmed in for the test. Stubs may also record information about calls.
- A mock object is a dummy implementation for an interface or a class in which you define the output of certain method calls. Mock objects are configured to perform a certain behaviour during a test. They typically record the interaction with the system and tests can validate that.

يمكن نقل مضاعفات الاختبار إلى الكائنات الأخرى التي يتم اختبارها.

يمكنك إنشاء كائنات وهمية يدوياً (عبر الكود) أو استخدام إطار صوري لمحاكاة هذه الصفوف الدراسية. تسمح لك الأطر الوهمية بإنشاء كائنات وهمية في وقت التشغيل وتحديد سلوكها. المثال الكلاسيكي لكائن صوري هو موفر البيانات. ويستخدم في إنتاج برنامج تنفيذي للاتصال بالمصدر الحقيقي للبيانات. ولكن لاختبار جسم صوري يحاكي مصدر البيانات ويكفل أن تكون ظروف الاختبار هي نفسها دائما.
